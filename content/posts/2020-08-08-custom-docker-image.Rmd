---
title: Custom Docker Image
author: Michael Bach
date: '2020-08-08'
slug: custom-docker-image
categories: ["development"]
images: ~
---

![](/images/Docker_logo.png)

---------------------------------------

> **TL;DR**
>
> Creating your own Docker image is fairly easy, when using a parent image. Basically, you pull the parent image and set up your specifications according to your needs for your custom container. You can specify pretty much everything in your *Dockerfile*.

---------------------------------------

In this post I'd like to give a quick overview of how to customize a python container set up. This could be an advantage if you develop in teams or require certain software releases or just don't want to setup everything manually for every project. You could either build an image from scratch of use a parent image and customize it to your needs. I'll focus on customizing a parent image as it suits my needs perfectly. Creating your own image might be necessary for certain usecases. However, most of the time it's sufficient building on a parent image as many smart people already invested some time in developing it.

## Basic Requirements

Obvisouseliy, you should have Docker installed in your environment. If you don't have Docker installed yet, check out my post on [Getting started with Docker](https://mic-bac.netlify.app/posts/getting-started-with-docker/).

Create a folder where you would like to save your Dockerfile and any additional files you might need.

That's pretty much it! Now you're good to start customizing your Docker image.


## Dockerfile

Use Dockerfile to run your application.

In your Dockerfile, you'll need to add some arguments. Some of them are required and some are useful to specifiy your custom image:

- `FROM` initializes a new build stage and sets the Base Image for subsequent instructions. A valid Dockerfile must start with the `FROM` instruction.
- `ARG` is the only instruction that may precede `FROM` in the Dockerfile. It's basically used to specify variables in a Dockerfile. But, if it's called before `FROM` it's declared as being outside the building stage and cannot be used in further steps. If needed, you'll have to call it again after `FROM` without a value.
- `WORKDIR` sets the working directory for any `RUN`, `CMD`, `ENTRYPOINT`, `COPY` and `ADD` instructions that follow it in the Dockerfile. If the `WORKDIR` doesn't exist, it will be created even if it's not used in any subsequent Dockerfile instruction.
- `COPY` copies new files or directories from the source and adds them to the filesystem of the container at the path destination `COPY <src> <dest>`.
- `RUN` will execute any commands in a new layer on top of the current image and commit the results. The resulting committed image will be used for the next step in the Dockerfile. `RUN` can either be used in shell form `RUN <command>` or exec form `RUN ["executable", "param1", "param2"]`. The exec form is parsed as a JSON array, which means that you must use double-quotes (") around words not single-quotes (').
- `CMD` can only be called once in a Dockerfile (last `CMD` will take effect). It's preferred to be used in the exec form CMD `["executable","param1","param2"]`.



```
# [optional] add arguments for FROM
ARG VERSION=3.9

# chose your source
FROM python:${VERSION}

# add working directory from parent
WORKDIR /usr/src/app

# copy requirements
COPY requirements.txt ./

# install requirements
RUN pip install --no-cache-dir -r requirements.txt

# copy all files from source to destination
COPY . .

# command to run on container start
CMD [ "python", "./your-daemon-or-script.py" ]
```

The above example also requires a *requirements.txt* file indicating the necessary python libraries you would like to install in your container.

Your Docker file is executed sequentially. 


I hope this post was informative. Feel free to contact me for any feedback :)




